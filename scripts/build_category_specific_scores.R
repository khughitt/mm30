#!/bin/env Rscript
#
# Combines feature associations from multiple sources
#
# Note: for some useful notes and diagrams on choosing a method to combine p-values,
# refer to figures 4-5 in the [metap compare
# vignette](https://cran.r-project.org/web/packages/metap/vignettes/compare.pdf).
#
# Warnings may be raised by sumz(), if P-values equal to "1" are encountered. These are handled
# automatically by the method.
# https://www.rdocumentation.org/packages/metap/versions/1.8/topics/sumz
#
suppressMessages(library(arrow))
suppressMessages(library(metap))
suppressMessages(library(metafor))
suppressMessages(library(tidyverse))

snek <- snakemake

# load dataset gene- or pathway-level effect sizes, standard errors and p-values calculated by 
# fassoc, along with the experiment metadata
pvals <- read_feather(snek@input[["pvals"]])
effects <- read_feather(snek@input[["effects"]])
errors <- read_feather(snek@input[["errors"]])
mdata <- read_feather(snek@input[["mdata"]])

id_field <- colnames(pvals)[1]

# normalize contributions from each dataset?
# if enabled, the minimum p-value / max effect size associated with each dataset will be used
if (snek@config$normalize_dataset_contributions) {
  feature_ids <- pull(pvals, id_field)

  min_pval_list <- list(feature_ids)
  max_effect_list <- list(feature_ids)
  max_effect_error_list <- list(feature_ids)

  dataset_ids <- unique(str_split(colnames(pvals)[-1], "_", simplify=TRUE)[, 1])

  for (id_ in dataset_ids) {
    # get columns corresponding to dataset
    mask <- startsWith(colnames(pvals), id_)

    if (sum(mask) == 1) {
      min_pval_list <- c(min_pval_list, list(pull(pvals[, mask], 1)))
      max_effect_list <- c(max_effect_list, list(pull(effects[, mask], 1)))
      max_effect_error_list <- c(max_effect_error_list, list(pull(errors[, mask], 1)))
    } else {
      # get minimum p-values for each dataset
      # hide warnings from generated by genes for which dataset has no non-missing values
      min_pvals <- suppressWarnings(apply(pvals[, mask, drop=FALSE], 1, min, na.rm=TRUE))
      min_pval_list <- c(min_pval_list, list(c(min_pvals)))

      # get max effect size + corresponding std error
      effects_subset <- as.matrix(effects[, mask, drop=FALSE])
      errors_subset <- as.matrix(errors[, mask, drop=FALSE])

      max_ind <- max.col(abs(effects_subset), "first")

      max_effects <- c()
      max_effect_errors <- c()

      for (i in seq_len(nrow(effects))) {
        if (is.na(max_ind[i])) {
          max_effects <- c(max_effects, NA)
          max_effect_errors <- c(max_effect_errors, NA)
        } else {
          max_effects <- c(max_effects, as.numeric(effects_subset[i, max_ind[i]]))
          max_effect_errors <- c(max_effect_errors, as.numeric(errors_subset[i, max_ind[i]]))
        }
      }
      max_effect_list <- c(max_effect_list, list(c(max_effects)))
      max_effect_error_list <- c(max_effect_error_list, list(c(max_effect_errors)))
    }
  }

  # convert back to tibbles
  names(min_pval_list) <- c(id_field, dataset_ids)
  names(max_effect_list) <- c(id_field, dataset_ids)
  names(max_effect_error_list) <- c(id_field, dataset_ids)

  pvals <- as_tibble(min_pval_list)
  effects <- as_tibble(max_effect_list)
  errors <- as_tibble(max_effect_error_list)
}

# create matrix versions of each without the id columns
pval_mat <- pvals %>%
  select(-all_of(id_field)) %>%
  as.matrix()

effect_mat <- effects %>%
  select(-all_of(id_field)) %>%
  as.matrix()

error_mat <- errors %>%
  select(-all_of(id_field)) %>%
  as.matrix()

# replace infinite values with "NA"
pval_mat[is.infinite(pval_mat)] <- NA
effect_mat[is.infinite(effect_mat)] <- NA
error_mat[is.infinite(error_mat)] <- NA

# replace "0" effect sizes with "NA"
effect_mat[effect_mat == 0] <- NA

# sanity check
if (!all(colnames(pval_mat) %in% mdata$dataset)) {
  stop("Missing metadata for one or more datasets!")
}

# count number of missing p-values for each gene or gene set
num_missing <- apply(pval_mat, 1, function(x) {
  sum(is.na(x))
})
num_present <- ncol(pval_mat) - num_missing

# wrap sumz and sumlog functions to handle missing values and insufficient data cases
sumlog_wrapper <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 1) {
    x
  } else if (length(x) == 0) {
    NA
  } else {
    as.numeric(sumlog(x)$p)
  }
}

sumz_wrapper <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 1) {
    x
  } else if (length(x) == 0) {
    NA
  } else {
    tryCatch({
      suppressWarnings(as.numeric(sumz(x)$p))
    }, error=function(e) {
      NA
    })
  }
}

# compute weighted sumz using sqrt(sample size) as weights
# see: https://onlinelibrary.wiley.com/doi/10.1111/j.1420-9101.2011.02297.x
weights <- sqrt(mdata$num_samples[match(colnames(pval_mat), mdata$dataset)])

sumz_wt_pvals <- c()

for (i in seq_len(nrow(pvals))) {
  row_pvals <- pval_mat[i, ]

  mask <- !is.na(row_pvals)

  row_pvals <- row_pvals[mask]
  filtered_weights <- weights[mask]

  # on rare occasions, sumz may fail for certain edge cases,
  # a tryCatch block is used to allow snek to continue

  # if there are one or fewer pvals remaining,
  if (length(row_pvals) == 1) {
    sumz_wt_pvals <- c(sumz_wt_pvals, row_pvals)
  } else if (length(row_pvals) == 0) {
    sumz_wt_pvals <- c(sumz_wt_pvals, NA)
  } else {
    sumz_pval <- tryCatch({
      as.numeric(sumz(row_pvals, weights=filtered_weights)$p)
    }, error=function(e) {
      NA
    })

    sumz_wt_pvals <- c(sumz_wt_pvals, sumz_pval)
  }
}

# effect size aggregation
metafor_pvals <- c()

for (i in seq_len(nrow(effect_mat))) {
  gene_effects <- as.numeric(effect_mat[i, ])
  gene_std_errors <- as.numeric(error_mat[i, ])

  # log-transform hazard ratios
  if (snakemake@wildcards$category %in% c("survival_os", "survival_pfs")) {
    gene_effects <- log(gene_effects)
  }

  pval <- tryCatch({
    # coef(summary(fit))
    #         estimate       se     zval      pval     ci.lb    ci.ub
    # intrcpt 17.10576 16.90056 1.012141 0.3114705 -16.01874 50.23026
    fit <- rma(gene_effects, sei=gene_std_errors)
    coefs <- coef(summary(fit))
    coefs[, "pval"]
  }, error=function(e) {
    NA
  })

  metafor_pvals <- c(metafor_pvals, pval)
}

# construct summary dataframe
res <- data.frame(
  pull(pvals, id_field),
  mean_pval     = apply(pval_mat, 1, mean, na.rm=TRUE),
  median_pval   = apply(pval_mat, 1, median, na.rm=TRUE),
  min_pval      = apply(pval_mat, 1, min, na.rm=TRUE),
  mean_effect   = apply(effect_mat, 1, mean, na.rm=TRUE),
  median_effect = apply(effect_mat, 1, median, na.rm=TRUE),
  mean_error    = apply(error_mat, 1, mean, na.rm=TRUE),
  median_error  = apply(error_mat, 1, median, na.rm=TRUE),
  num_sig_p05   = apply(pval_mat, 1, function(x) {
    sum(x < 0.05, na.rm=TRUE)
  }),
  num_sig_p01   = apply(pval_mat, 1, function(x) {
    sum(x < 0.01, na.rm=TRUE)
  }),
  num_sig_p001  = apply(pval_mat, 1, function(x) {
    sum(x < 0.001, na.rm=TRUE)
  }),
  sumlog_pval   = suppressWarnings(apply(pval_mat, 1, sumlog_wrapper)),
  sumz_pval     = suppressWarnings(apply(pval_mat, 1, sumz_wrapper)),
  sumz_wt_pval  = sumz_wt_pvals,
  metafor_pval  = metafor_pvals,
  num_present,
  num_missing
)
colnames(res)[1] <- id_field

# drop any genes with missing values for the aggregated scores
res <- res[complete.cases(res), ]

# reorder and store results
res <- res %>%
  arrange(sumz_wt_pval)

# store results
write_feather(res, snek@output[[1]])
