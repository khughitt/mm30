#!/bin/env Rscript
#
# Combines feature associations from multiple sources
#
# Note: for some useful notes and diagrams on choosing a method to combine p-values,
# refer to figures 4-5 in the [metap compare
# vignette](https://cran.r-project.org/web/packages/metap/vignettes/compare.pdf).
# ----------
#
suppressMessages(library(arrow))
suppressMessages(library(metap))
suppressMessages(library(tidyverse))

# load dataset gene- or pathway-level p-values calculated by fassoc, along with the
# experiment metadata
pvals <- read_feather(snakemake@input[['pvals']])
mdata <- read_feather(snakemake@input[['mdata']])

id_field <- colnames(pvals)[1]

# normalize contributions from each dataset?
# if enabled, for each experiment for which multiple covariates analyzed, for each gene,
# the minimum p-value observed across all p-values will be used, rather than providing
# metap with multple p-values for a single gene/experiment.
if (snakemake@config$normalize_dataset_contributions) {
  min_pval_list <- list(pull(pvals, id_field))

  dataset_ids <- unique(str_split(colnames(pvals)[-1], '_', simplify = TRUE)[, 1])

  for (id_ in dataset_ids) {
    # collapse columns for dataset into a single column
    mask <- startsWith(colnames(pvals), id_)

    # get minimum p-values for each dataset
    # hide warnings from generated by genes for which dataset has no non-missing values
    min_pvals <- suppressWarnings(apply(pvals[, mask, drop = FALSE], 1, min, na.rm = TRUE))
    min_pvals[is.infinite(min_pvals)] <- NA

    min_pval_list <- c(min_pval_list, list(c(min_pvals)))
  } 

  # convert back to a tibble
  names(min_pval_list) <- c(id_field, dataset_ids)

  pvals <- as_tibble(min_pval_list)
}

# create matrix versions of the p-values without the id column
pval_mat <- pvals %>%
  select(-all_of(id_field)) %>%
  as.matrix()

# count number of missing values for each gene or gene set
num_missing <- apply(pval_mat, 1, function(x) {
  sum(is.na(x))
})
num_present <- ncol(pval_mat) - num_missing

# wrap sumz and sumlog functions to handle missing values and insufficient data cases
sumlog_wrapper <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 1) {
    x
  } else if (length(x) == 0) {
    NA
  } else {
    as.numeric(sumlog(x)$p)
  }
}

sumz_wrapper <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 1) {
    x
  } else if (length(x) == 0) {
    NA
  } else {
    tryCatch({
      suppressWarnings(as.numeric(sumz(x)$p))
    }, error = function(e) {
      NA
    })
  }
}

# compute weighted sumz using sqrt(sample size) as weights
# see: https://onlinelibrary.wiley.com/doi/10.1111/j.1420-9101.2011.02297.x
weights <- sqrt(mdata$num_samples[match(colnames(pval_mat), mdata$dataset)])

sumz_wt_pvals <- c()

for (i in 1:nrow(pvals)) {
  row_pvals <- pval_mat[i, ]

  mask <- !is.na(row_pvals)

  row_pvals <- row_pvals[mask]
  filtered_weights <- weights[mask]

  # on rare occasions, sumz may fail for certain edge cases,
  # a tryCatch block is used to allow snakemake to continue

  # if there are one or fewer pvals remaining, 
  if (length(row_pvals) == 1) {
    sumz_wt_pvals <- c(sumz_wt_pvals, row_pvals)
  } else if (length(row_pvals) == 0) {
    sumz_wt_pvals <- c(sumz_wt_pvals, NA)
  } else {
    sumz_pval <- tryCatch({
      as.numeric(sumz(row_pvals, weights = filtered_weights)$p)
    }, error = function(e) {
      NA
    })

    sumz_wt_pvals <- c(sumz_wt_pvals, sumz_pval)
  }
}

# summary dataframe containing aggregated pvalues
res <- data.frame(
  pull(pvals, id_field),
  mean_pval    = apply(pval_mat, 1, mean, na.rm = TRUE),
  median_pval  = apply(pval_mat, 1, median, na.rm = TRUE),
  min_pval     = apply(pval_mat, 1, min, na.rm = TRUE),
  sumlog_pval  = suppressWarnings(apply(pval_mat, 1, sumlog_wrapper)),
  sumz_pval    = suppressWarnings(apply(pval_mat, 1, sumz_wrapper)),
  sumz_wt_pval = sumz_wt_pvals,
  num_present,
  num_missing
)
colnames(res)[1] <- id_field

# drop any genes with missing values for the aggregated scores 
res <- res[complete.cases(res), ]

# reorder and store results
res <- res %>%
  arrange(sumz_wt_pval)

# store results
write_feather(res, snakemake@output[[1]])
