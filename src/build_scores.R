#!/bin/env Rscript
#
# Combines feature associations from multiple sources
#
# Note: for some useful notes and diagrams on choosing a method to combine p-values,
# refer to figures 4-5 in the [metap compare
# vignette](https://cran.r-project.org/web/packages/metap/vignettes/compare.pdf).
# ----------
#
suppressMessages(library(arrow))
suppressMessages(library(metap))
suppressMessages(library(tidyverse))

# load dataset gene- or pathway-level p-values calculcated by fassoc
pvals <- read_feather(snakemake@input[['pvals']])
stats <- read_feather(snakemake@input[['stats']])

# load feature-phenotype association metadata
input_dir <- file.path(snakemake@config$fassoc_dir, "mm25", snakemake@config["version"])

infile <- file.path(input_dir, "metadata", "association_metadata.feather")
associations <- read_feather(infile)

id_field <- colnames(pvals)[1]

# for constructing targeted feature scores, limit to p-values from a single category
if ("category" %in% names(snakemake@params)) {
  # get a list of associations of the desired category
  pheno_subset <- associations %>%
    filter(category == snakemake@params$category)

  # remove associations that are not in the specified category
  cols_to_keep <- sprintf("%s_%s", pheno_subset$dataset, pheno_subset$phenotype)
  cols_to_keep <- c(id_field, cols_to_keep)

  mask <- colnames(pvals) %in% cols_to_keep
  pvals <- pvals[, mask]
  stats <- stats[, mask]

  # drop any features that no longer have any non-missing values after filtering
  num_non_na <- apply(pvals, 1, function(x) {
    sum(!is.na(x))
  })

  pvals <- pvals[num_non_na > 1, ]
  stats <- stats[num_non_na > 1, ]
}

# normalize contributions from each dataset, if enabled;
# note: for some metap methods, weights can also be specified for each p-value..
if (snakemake@config$normalize_dataset_contributions) {
  min_pval_list <- list(pull(pvals, id_field))
  max_stat_list <- list(pull(stats, id_field))

  dataset_ids <- unique(str_split(colnames(pvals)[-1], '_', simplify = TRUE)[, 1])

  for (id_ in dataset_ids) {
    # collapse columns for dataset into a single column
    mask <- startsWith(colnames(pvals), id_)

    # get minimum p-values for each dataset
    # hide warnings from generated by genes for which dataset has no non-missing values
    min_pvals <- suppressWarnings(apply(pvals[, mask, drop = FALSE], 1, min, na.rm = TRUE))
    min_pvals[is.infinite(min_pvals)] <- NA

    min_pval_list <- c(min_pval_list, list(c(min_pvals)))

    # get maximum statistics for each dataset
    max_stats <- suppressWarnings(apply(stats[, mask, drop = FALSE], 1, function (x) {
      max(abs(x), na.rm = TRUE)
    }))
    max_stats[is.infinite(max_stats)] <- NA

    max_stat_list <- c(max_stat_list, list(c(max_stats)))
  } 

  # convert back to a tibble
  names(min_pval_list) <- c(id_field, dataset_ids)
  names(max_stat_list) <- c(id_field, dataset_ids)

  pvals <- as_tibble(min_pval_list)
  stats <- as_tibble(max_stat_list)
}

# create matrix versions of the p-values without the id column
pval_mat <- pvals %>%
  select(-all_of(id_field)) %>%
  as.matrix()

stat_mat <- stats %>%
  select(-all_of(id_field)) %>%
  as.matrix()

# count number of missing values for each gene or gene set
num_missing <- apply(pval_mat, 1, function(x) {
  sum(is.na(x))
})
num_present <- ncol(pval_mat) - num_missing

save.image('~/tmp.rda')

# wrap sumz and sumlog functions to handle missing values and insufficient data cases
sumlog_wrapper <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 1) {
    x
  } else if (length(x) == 0) {
    NA
  } else {
    as.numeric(sumlog(x)$p)
  }
}

sumz_wrapper <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 1) {
    x
  } else if (length(x) == 0) {
    NA
  } else {
    tryCatch({
      suppressWarnings(as.numeric(sumz(x)$p))
    }, error = function(e) {
      message(i)
      NA
    })
  }
}

# compute weighted sumz using stats as weights
sumz_wt_pvals <- c()

for (i in 1:nrow(pvals)) {
  row_pvals <- pval_mat[i, ]
  row_stats <- stat_mat[i, ]

  row_pvals <- row_pvals[!is.na(row_pvals)]
  row_stats <- row_stats[!is.na(row_stats)]

  # on rare occasions, sumz may fail for certain edge cases,
  # ex: sumz(c(6.44634146544944e-09, 1), c(33.7, 1133259850869713))
  # tryCatch block used to allow snakemake to continue

  # if there are one or fewer pvals remaining, 
  if (length(row_pvals) == 1) {
    sumz_wt_pvals <- c(sumz_wt_pvals, row_pvals)
  } else if (length(row_pvals) == 0) {
    sumz_wt_pvals <- c(sumz_wt_pvals, NA)
  } else {
    sumz_pval <- tryCatch({
      as.numeric(sumz(row_pvals, weights = abs(row_stats))$p)
    }, error = function(e) {
      message(i)
      NA
    })

    sumz_wt_pvals <- c(sumz_wt_pvals, sumz_pval)
  }
}


# summary dataframe containing aggregated pvalues
res <- data.frame(
  pull(pvals, id_field),
  mean_pval   = apply(pval_mat, 1, mean, na.rm = TRUE),
  median_pval = apply(pval_mat, 1, median, na.rm = TRUE),
  min_pval    = apply(pval_mat, 1, min, na.rm = TRUE),
  sumlog_pval = suppressWarnings(apply(pval_mat, 1, sumlog_wrapper)),
  sumz_pval   = suppressWarnings(apply(pval_mat, 1, sumz_wrapper)),
  sumz_wt_pval = sumz_wt_pvals,
  num_present,
  num_missing
)
colnames(res)[1] <- id_field

# reorder and store results
res <- res %>%
  arrange(sumz_wt_pval)

# store results
write_feather(res, snakemake@output[[1]])
